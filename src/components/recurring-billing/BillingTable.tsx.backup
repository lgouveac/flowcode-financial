import { Table, TableBody, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import type { RecurringBilling } from "@/types/billing";
import { RecurringBillingRow } from "./RecurringBillingRow";
import { useState } from "react";
import { PaymentDetailsDialog } from "./PaymentDetailsDialog";
import { PaymentDetailsDialog as IndividualPaymentDialog } from "../payments/PaymentDetailsDialog";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";
import { EmailTemplate } from "@/types/email";
import { EmptyState } from "../payments/EmptyState";
import { Payment } from "@/types/payment";
import { Trash2 } from "lucide-react";

interface BillingTableProps {
  billings: Array<RecurringBilling & { clients?: { name: string; responsible_name?: string } }>;
  onRefresh?: () => void;
  enableDuplicate?: boolean;
  templates?: EmailTemplate[];
}

export const BillingTable = ({ billings, onRefresh, enableDuplicate, templates = [] }: BillingTableProps) => {
  const [selectedBilling, setSelectedBilling] = useState<RecurringBilling | null>(null);
  const [selectedPayment, setSelectedPayment] = useState<Payment | null>(null);
  const [showPaymentDetails, setShowPaymentDetails] = useState(false);
  const [showIndividualPaymentDetails, setShowIndividualPaymentDetails] = useState(false);
  const [selectedBillings, setSelectedBillings] = useState<Set<number>>(new Set());
  const [isDeleting, setIsDeleting] = useState(false);
  const { toast } = useToast();

  const handleOpenDetails = (billing: RecurringBilling) => {
    if (billing.individual_payment) {
      setSelectedPayment(billing.individual_payment);
      setShowIndividualPaymentDetails(true);
    } else if (billing.is_virtual) {
      setSelectedBilling(billing);
      setShowPaymentDetails(true);
    } else {
      setSelectedBilling(billing);
      setShowPaymentDetails(true);
    }
  };

  const handleCloseDetails = () => {
    setShowPaymentDetails(false);
    setSelectedBilling(null);
    if (onRefresh) {
      onRefresh();
    }
  };

  const handleCloseIndividualDetails = () => {
    setShowIndividualPaymentDetails(false);
    setSelectedPayment(null);
    if (onRefresh) {
      onRefresh();
    }
  };

  const handleUpdate = () => {
    if (onRefresh) {
      onRefresh();
    }
  };

  const handleSelectBilling = (billingId: number, checked: boolean) => {
    const newSelected = new Set(selectedBillings);
    if (checked) {
      newSelected.add(billingId);
    } else {
      newSelected.delete(billingId);
    }
    setSelectedBillings(newSelected);
  };

  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      const allIds = new Set(billings.map(b => b.id));
      setSelectedBillings(allIds);
    } else {
      setSelectedBillings(new Set());
    }
  };

  const handleBulkDelete = async () => {
    if (selectedBillings.size === 0) return;

    const confirmed = window.confirm(
      `Tem certeza que deseja deletar ${selectedBillings.size} recebimento(s) selecionado(s)?`
    );

    if (!confirmed) return;

    setIsDeleting(true);
    try {
      const recurringBillingIds = [];
      const paymentIds = [];

      const selectedBillingObjects = billings.filter(billing =>
        selectedBillings.has(billing.id)
      );

      selectedBillingObjects.forEach(billing => {
        if (billing.individual_payment) {
          paymentIds.push(billing.individual_payment.id);
        } else if (billing.related_payments) {
          billing.related_payments.forEach(payment => {
            paymentIds.push(payment.id);
          });
        } else {
          let realId = billing.id;
          if (typeof realId === 'string') {
            realId = realId.replace(/^(open-|closed-|expanded-open-|expanded-)/, '');
          }

          if (typeof realId === 'string' && realId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)) {
            recurringBillingIds.push(realId);
          } else {
            paymentIds.push(realId);
          }
        }
      });

      const promises = [];

      if (recurringBillingIds.length > 0) {
        promises.push(
          supabase
            .from('recurring_billing')
            .delete()
            .in('id', recurringBillingIds)
        );
      }

      if (paymentIds.length > 0) {
        promises.push(
          supabase
            .from('payments')
            .delete()
            .in('id', paymentIds)
        );
      }

      if (promises.length === 0) {
        throw new Error('Nenhum ID válido encontrado para deletar');
      }

      const results = await Promise.all(promises);

      const errors = results.filter(result => result.error);
      if (errors.length > 0) {
        console.error('Alguns erros ocorreram:', errors);
        throw new Error(errors[0].error.message);
      }

      toast({
        title: "Sucesso",
        description: `${selectedBillings.size} recebimento(s) deletado(s) com sucesso.`,
      });

      setSelectedBillings(new Set());
      if (onRefresh) {
        onRefresh();
      }
    } catch (error) {
      console.error('Erro ao deletar recebimentos:', error);
      toast({
        title: "Erro",
        description: error.message || "Não foi possível deletar os recebimentos selecionados.",
        variant: "destructive",
      });
    } finally {
      setIsDeleting(false);
    }
  };

  const isAllSelected = billings.length > 0 &&
    billings.every(billing => selectedBillings.has(billing.id));
  const isPartiallySelected = selectedBillings.size > 0 && !isAllSelected;

  const handleDuplicate = async (billing: RecurringBilling): Promise<void> => {
    try {
      const newBilling = {
        client_id: billing.client_id,
        description: `${billing.description} (Cópia)`,
        amount: billing.amount,
        due_day: billing.due_day,
        payment_method: billing.payment_method,
        start_date: billing.start_date,
        end_date: billing.end_date,
        status: 'pending' as const,
        installments: billing.installments,
        current_installment: 1,
        email_template: billing.email_template
      };

      const { data, error } = await supabase
        .from('recurring_billing')
        .insert([newBilling])
        .select()
        .single();

      if (error) throw error;

      toast({
        title: "Cobrança duplicada",
        description: "A cobrança recorrente foi duplicada com sucesso."
      });

      if (onRefresh) {
        onRefresh();
      }
    } catch (error) {
      console.error("Erro ao duplicar cobrança:", error);
      toast({
        title: "Erro ao duplicar",
        description: "Não foi possível duplicar a cobrança.",
        variant: "destructive"
      });
      throw error;
    }
  };

  if (billings.length === 0) {
    return <EmptyState />;
  }

  return (
    <div className="space-y-4">
      {selectedBillings.size > 0 && (
        <div className="flex items-center justify-between p-3 bg-muted rounded-md">
          <span className="text-sm font-medium">
            {selectedBillings.size} recebimento(s) selecionado(s)
          </span>
          <Button
            onClick={handleBulkDelete}
            disabled={isDeleting}
            variant="destructive"
            size="sm"
          >
            <Trash2 className="h-4 w-4 mr-2" />
            {isDeleting ? "Deletando..." : "Deletar Selecionados"}
          </Button>
        </div>
      )}

      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="w-[50px]">
                <Checkbox
                  checked={isAllSelected}
                  onCheckedChange={handleSelectAll}
                  indeterminate={isPartiallySelected}
                  aria-label="Selecionar todos"
                />
              </TableHead>
              <TableHead>Cliente</TableHead>
              <TableHead>Descrição</TableHead>
              <TableHead>Valor</TableHead>
              <TableHead>Vencimento</TableHead>
              <TableHead>Status</TableHead>
              <TableHead className="text-right">Ações</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {billings.map((billing) => (
              <RecurringBillingRow
                key={billing.id}
                billing={billing}
                onRefresh={onRefresh || (() => {})}
                onOpenDetails={handleOpenDetails}
                onDuplicate={handleDuplicate}
                enableDuplicate={enableDuplicate}
                templates={templates}
                isSelected={selectedBillings.has(billing.id)}
                onSelectChange={handleSelectBilling}
              />
            ))}
          </TableBody>
        </Table>
      </div>

      {selectedBilling && (
        <PaymentDetailsDialog
          billing={selectedBilling}
          open={showPaymentDetails}
          onClose={handleCloseDetails}
          onUpdate={handleUpdate}
          templates={templates}
        />
      )}

      {selectedPayment && (
        <IndividualPaymentDialog
          payment={selectedPayment}
          open={showIndividualPaymentDetails}
          onClose={handleCloseIndividualDetails}
          onUpdate={handleUpdate}
          templates={templates}
        />
      )}
    </div>
  );
};